<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Blog of MianTang]]></title>
  
  <link href="/blog/atom.xml" rel="self"/>
  <link href="http://ppii.in/blog/blog//"/>
  <updated>2015-07-11T14:36:38.447Z</updated>
  <id>http://ppii.in/blog/blog//</id>
  
  <author>
    <name><![CDATA[面汤]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[我所理解的弹幕艺术(Comment Art)]]></title>
    <link href="http://ppii.in/blog/blog/2015/07/11/what-about-comment-art/"/>
    <id>http://ppii.in/blog/blog/2015/07/11/what-about-comment-art/</id>
    <published>2015-07-10T16:00:00.000Z</published>
    <updated>2015-07-11T14:36:38.447Z</updated>
    <content type="html"><![CDATA[<p><a href="http://www.zhihu.com/question/30274886/answer/54683454" target="_blank" rel="external">原是在知乎的答帖</a></p>
<h3 id="0-_什么是弹幕艺术？">0. 什么是弹幕艺术？</h3><p>弹幕艺术，即以弹幕丰富的内容与变化为主要形式，以弹幕视频为载体，依托Niconico动画、bilibili、ACFUN等弹幕视频网站的一种新兴的艺术形式。</p>
<p>个人身份：哔哩哔哩职人弹幕君，弹幕艺术布道者。2012年B站拜年祭弹幕作品作者，第二届蓝白弹幕合战参与者，第三届蓝白弹幕祭主催。</p>
<pre><code>自从b站引入了高级弹幕,提供类似ECMAScript的脚本语言以及对播放器和弹幕进行控制的能力,弹幕本身理论上跟AE之类的工具能达到同样的效果<span class="comment">(不考虑性能消耗)</span>,那么选择弹幕艺术而不是制作视频的原因是什么?
</code></pre><p>总的来说，于个人而言，原因一定包含以下三点：</p>
<h3 id="1-_在弹幕网站寻找认同感。">1. 在弹幕网站寻找认同感。</h3><p>问题描述中也提到，</p>
<pre><code>弹幕艺术是以弹幕内容/变化为主要形式，以弹幕视频为载体，依托各大弹幕视频网站的一种新兴的艺术形式。
</code></pre><p>弹幕是完全依附于弹幕网站的。这些弹幕视频网站有一个特点，那就是都有着其他视频站比不了的用户忠诚度和网站凝聚力。因此在某种程度上，发布一份弹幕作品，在相关的兴趣圈子里可以很好地寻找到认同感，也能在相互交流的过程中得到正反馈。</p>
<p>这是让大部分制作者持续做下去的一个很重要的原因。</p>
<h3 id="2-_传达依托的音乐的感情主题。">2. 传达依托的音乐的感情主题。</h3><p>以现有的弹幕艺术类作品来看，基本上大部分的制作者的选曲都是他们的热爱的主题/喜欢的歌曲（比如东方Project、 Vocaloid和一些ACG类曲目）。</p>
<p>对歌曲主题本身的兴趣和喜爱，这是驱动他们花费许多时间制作弹幕作品的动力所在。</p>
<h3 id="3-_在弹幕作品制作过程中寻找乐趣，自我满足。">3. 在弹幕作品制作过程中寻找乐趣，自我满足。</h3><p>这应该是每个纯粹的职人弹幕君制作弹幕最主要的原因吧。</p>
<p>大部分制作者的乐趣，一般都起源于新鲜感和好奇心，之后因人而异。我仅谈谈我能从哪些弹幕中找到乐趣。</p>
<p><strong>一种弹幕（Acfun/Nico/Bili的定位弹幕），主要依靠不同字符的变化与组合。</strong></p>
<p>比如：</p>
<p>依靠黑色字符“■”和固定弹幕的组合，依靠“弹幕越长弹幕滚动速度越快”这个概念实现的不一样的视觉感官。如裸眼3D，甚至滚动变换（当初文科生的噩梦）</p>
<p><img src="/blog/images/what-about-comment-art/1.jpg" alt="1"></p>
<p>示例：<a href="http://www.bilibili.com/video/av41088/" target="_blank">【阿姨说】_其他</a></p>
<p><a href="http://www.bilibili.com/video/av58515/" target="_blank">[120%] HERO - 亿千万的感谢 [黑屏+弹幕游乐场]_其他</a></p>
<p>（4、5年前的作品，观看最好屏蔽普通弹幕）</p>
<p>仅仅是简单的弹幕，却与视频（音乐）的完美契合，带来的美的享受。</p>
<p><img src="/blog/images/what-about-comment-art/2.jpg" alt="2"></p>
<p>示例：[第一回蓝白弹幕合战]白夢の繭<a href="http://danmaku.us/Bilibili2/1046" target="_blank" rel="external">http://danmaku.us/Bilibili2/1046</a></p>
<p><img src="/blog/images/what-about-comment-art/3.png" alt="3"></p>
<p><a href="http://www.bilibili.com/video/av122646/" target="_blank">[第二回蓝白弹幕合战][蓝组]</a></p>
<p>依靠生存时间和消失时间的差值逐帧实现的超越播放器本身的固有的字符特效。</p>
<p>用一些特殊字符(七巧板)，组合成的字符弹幕画</p>
<p><img src="/blog/images/what-about-comment-art/4.png" alt="4"><br><img src="/blog/images/what-about-comment-art/5.jpg" alt="5"><br><img src="/blog/images/what-about-comment-art/6.jpg" alt="6"><br><img src="/blog/images/what-about-comment-art/7.jpg" alt="7"></p>
<p><strong>这些弹幕都在不同方面上体现了制作者的智慧与创意，而这种用有限的元素做出让人赏心悦目、触动心灵的弹幕，就是制作者的乐趣。</strong></p>
<p>——-戴着脚镣跳舞，拼七巧板的奇妙体验</p>
<p><strong>另一种弹幕（Bili/Nico的脚本弹幕），主要依靠弹幕播放器提供的固有API的脚本代码来实现。</strong></p>
<p>它去除了许多禁锢，并且实现方式上也大大增高了门槛（需要ECMAScript基础+更多的艺术细胞）。这种弹幕某种程度上剥夺了前面一种弹幕的乐趣。</p>
<p>然而依然能感受到新的乐趣：</p>
<p>依托固有的API探索新的弹幕表现，如3D：<br><img src="/blog/images/what-about-comment-art/8.jpg" alt="8"><br><img src="/blog/images/what-about-comment-art/9.jpg" alt="9"></p>
<p>示例：<a href="http://www.bilibili.com/video/av410205/" target="_blank" rel="external">【弹幕大赛】Round and Round【高级弹幕】</a></p>
<p>凭借字符画或者矢量画，制作音乐PV，弹幕MAD：</p>
<p><img src="/blog/images/what-about-comment-art/10.jpg" alt="10"></p>
<p><a href="http://www.bilibili.com/video/av451734/" target="_blank" rel="external">【纯弹幕MAD】命运石之门再现【NICO屏录版】【时长20分钟】</a></p>
<p><img src="/blog/images/what-about-comment-art/11.jpg" alt="11"></p>
<p><a href="http://www.bilibili.com/video/av411036/" target="_blank" rel="external">【黑屏弹幕】一首研究镜音的胸部里是什么的歌</a></p>
<p><img src="/blog/images/what-about-comment-art/12.jpg" alt="12"></p>
<p><a href="http://www.bilibili.com/video/av734560/" target="_blank" rel="external">【纯弹幕PV】第三回蓝白弹幕合作祭</a></p>
<p>甚至于另一个范畴，通过弹幕交互制作的弹幕游戏。</p>
<p><a href="http://www.bilibili.com/video/av612580/" target="_blank" rel="external">【弹幕AVG(伪)】玄天·律师事务所</a></p>
<p><a href="http://www.bilibili.com/video/av412614/" target="_blank" rel="external">【弹幕游戏】Hexagon弹幕移植版</a></p>
<p><strong>正如wonderfl、CodePen上的许多Flash动画、HTML5 Canvas动画那样，通过编写抽象的代码来具现自己的设计，从这种融合技术与艺术的过程，也能寻找到独特的乐趣。</strong></p>
<p>即使在这相对严苛的制作环境下，依然能做出震撼人心、让人大呼叫好的弹幕作品。<br>———探索弹幕的无限可能性</p>
<p><strong>弹幕的能力在扩展，弹幕艺术也就不会仅局限于我所提到的。弹幕艺术的概念也将会被更多的人所拓展。</strong></p>
<p>================================</p>
<h3 id="另一个问题，">另一个问题，</h3><pre><code>观众对于弹幕艺术之于静止画MAD/Kinetic typography视频作品态度的区别。
</code></pre><p>观众的态度恐怕难以概述。但必需说明的一点就是，“弹幕理论上跟After Effects之类的工具能达到同样的效果”。有一个重大的区别就是，脚本弹幕没有可视化工具（虽然我们一些有程序基础的弹幕君进行过开发这样的工具，但依然很难满足目前设计与编码的完全解耦需求，并且这种探索也因为一些非技术原因而变缓），</p>
<p>所以，大部分弹幕君的工作流都是记事本手写弹幕，制作难度并不低。而MAD之类的可是有强大的AE在啊。</p>
<p>理论上，我能从哈尔滨走路到南京，也能从哈尔滨坐飞机到南京。但是这能一样吗？</p>
<p>我想，既然都是以表现元素来传达作品主题，弹幕作品从要表达思想内容这一点来看，跟使用其他的载体是相通的吧。</p>
<p>只不过区别在于，弹幕作品使用的是一种“非主流”的技术载体而已。</p>
<p><strong>工具并不重要，重要的是作品要传达的内容。</strong></p>
<p><strong>不用太过关注观众怎么想，我们只需要勿忘初心，热爱自己的东西就可以了。</strong></p>
<p><strong>正如大家说的那样：这是技术宅的浪漫情怀w</strong></p>
<p>我想曾经的闪客、喜欢设计的前端工程师应该也能有类似的感觉吧=w=</p>
<p>================================</p>
<p>最后，以弹幕双子来结尾吧w：</p>
<p>姐姐有蓝色的长发，擅长使用Mode7(定位弹幕)，抖S，阳光并且乐于助人。即使是用简单的工具（七巧板），也能创造出十分美丽的弹幕！</p>
<p>弟弟有白色的短发，擅长使用Mode8(脚本弹幕)，抖M，一脸受样。会用奇怪的代码，能创造出很多令人震惊意想不到的弹幕！</p>
<p><img src="/blog/images/what-about-comment-art/13.jpg" alt="13"></p>
<p>更多作品：</p>
<p><a href="http://www.bilibili.com/sp/%E5%BC%B9%E5%B9%95%E8%89%BA%E6%9C%AF" target="_blank" rel="external">弹幕艺术<em>专题_bilibili</em>哔哩哔哩弹幕视频网</a></p>
<p><a href="http://www.bilibili.com/sp/NICO%E5%BC%B9%E5%B9%95%E8%89%BA%E6%9C%AF" target="_blank" rel="external">NICO弹幕艺术<em>专题_bilibili</em>哔哩哔哩弹幕视频网</a></p>
]]></content>
    <summary type="html">
    <![CDATA[弹幕艺术，即以弹幕丰富的内容与变化为主要形式，以弹幕视频为载体，依托Niconico动画、bilibili、ACFUN等弹幕视频网站的一种新兴的艺术形式。]]>
    
    </summary>
    
      <category term="Comment Art" scheme="http://ppii.in/blog/blog/tags/Comment-Art/"/>
    
      <category term="弹幕" scheme="http://ppii.in/blog/blog/tags/%E5%BC%B9%E5%B9%95/"/>
    
      <category term="弹幕艺术" scheme="http://ppii.in/blog/blog/categories/%E5%BC%B9%E5%B9%95%E8%89%BA%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[普通弹幕滚动变换的原理解析]]></title>
    <link href="http://ppii.in/blog/blog/2015/06/26/roll-change/"/>
    <id>http://ppii.in/blog/blog/2015/06/26/roll-change/</id>
    <published>2015-06-25T16:00:00.000Z</published>
    <updated>2015-07-11T14:31:52.742Z</updated>
    <content type="html"><![CDATA[<h2 id="一、基础原理">一、基础原理</h2><p>滚动MIKU的实现是以<strong>不同长度的弹幕</strong>所造成的<strong>速度差</strong>实现的。<br><img src="/blog/images/roll-change/1.jpg" alt="1"></p>
<p>如图所示，其中所谓不同长度是指，相邻的长度差为5个字符。<br>而这就造成了以下的结果：</p>
<div class="red"><br>移动每间隔4s/5即0.8秒，相邻长度差的弹幕有相对1个字符长度的位移。<br>正因为有了这1个字符长度的位移，我们就可以使用这个位移来进行遮盖，以达到变换的效果。而进行展示的时间点，则是0.8秒/1.6秒/2.4秒/3.2秒这四个时间点。<br></div>

<p>这个结论可以有很大的扩展空间。在滚动MIKU的例子中，所有的弹幕分为4种最大横向长度，并且相邻的长度差为5个字符：它们分别为2个字符/7个字符/12个字符/17个字符。而作为显示面板的弹幕，横向长度为12个字符。</p>
<p>那么如果我做这样的设计：所有的弹幕分为5种最大横向长度，并且相邻的长度差为4个字符：他们分别为2个字符/6个字符/10个字符/14个字符/18个字符。而作为显示面板的弹幕，横向长度为14个字符。又会出现何种状态呢？答案如下：</p>
<p>相邻长度差为4个字符，移动每间隔4s/4即1秒，相邻长度差的弹幕有相对1个字符长度的位移。而进行展示的时间点，则是1.0秒/2.0秒/3.0秒这三个时间点。</p>
<p>也就是说，可展示的变换状态的个数，就是长度差的字符数减一。比如我要展示BILI，长度差就需要为5，展示MIO，长度差就需要为4，展示2DLAND，长度差就需要为7了。</p>
<p><img src="/blog/images/roll-change/2.jpg" alt="2"></p>
<p>接下来说具体的数据。</p>
<p>刚才说的1个字符长度的位移，这是相对的。比如说以上图为例，以2-1『注，2-1表示最大弹幕长度为2的弹幕中的第1个位置的字符，下面都遵循这个表达。有时候为了防止歧义我会在外面加上[]来表示。』为基准位置，在0.0s的时候，所有弹幕在Bilibili的播放器中是右对齐的，并且有一个初始距离。但这里我们要注重的只是相对位置：也就是说，在0.0s的时候，所有弹幕的相对位置是0个字符。而在0.8s的时候，由于我们将2-1作为了基准位置，则结果就是，2-1的位置所对应的应该是7-2、12-3、17-4这三个位置（在图中由红框表示）。</p>
<p>那么这个结果是如何计算出来的呢？因为运动是相对的，所以我们要设定一个基准长度。而这个基准长度一般来说是刚才所说的展示面板的长度。在滚动MIKU的例子中为12个字符。但是现在我们暂且以图中的2个字符为基准长度来进行计算——</p>
<p><strong>目标位置 = 基准位置 + ((目标长度-基准长度) / 长度差)*（当前时间点/时间间隔）</strong></p>
<p>也就是说，如果我把目标长度定为12，在图中的意思就是：<br>x = 1 + ((12 - 2) / 5) <em> (0.8 / 0.8) = 1 + 2 </em> 1 = 3</p>
<p>意思就是2-1在0.8s处所对应的目标位置为12-3</p>
<p>可能有点晕，那就再做一次。这次我们把基准长度设定成滚动MIKU所使用的长度：12个字符。</p>
<p><img src="/blog/images/roll-change/3.jpg" alt="3"></p>
<p>公式还是这个：<br><strong>目标位置 = 基准位置 + ((目标长度 - 基准长度)  / 长度差)*（当前时间点 / 时间间隔）</strong></p>
<p>这回我们从12-2变换为17-x好了。<br>即<code>x = 2 + ((17 - 12) / 5) * (0.8 / 0.8) = 2 + 1 * 1 = 3</code></p>
<p>意思就是12-2在0.8s的时候对应的位置为17-3，如图中红框所示。</p>
<p>那么再来一次，这回从12-2变换为2-x看看。<br>即<code>x = 2 + ((2 - 12) / 5) * (0.8 / 0.8) = 2 + -2 * 1 = 0</code></p>
<p>显然x不可能小于等于0，所以这个变换是失败的，因为目标字符不存在。在图中可以看到，以方格中的红叉表示。</p>
<p>那让我们再次进行扩展：假如当前时间点为2.4秒，基准位置为12-4，需要变换到7-x。<br>即<code>x = 4 + ((7 - 12) / 5) * (2.4 / 0.8) = 4 + -1 * 3 = 1</code></p>
<p>也就是从12-4在2.4s所对应的位置为7-1。</p>
<p>可能光从这样的计算暂时还没法了解这个式子到底有什么深一层的含义，那就暂且先开始下一个部分好了。</p>
<h2 id="二、变换目标">二、变换目标</h2><p>在以前的分析报告里我好像写过盖板的样子，这里我就不再对盖板进行图示了。</p>
<p>『注意，红色的框表示滚动变换的效果显示区域。也是盖板所留空的区域。』</p>
<p>但是这个图对我们来说是没有什么太大用处的……真正有用的图是下一张——</p>
<p><img src="/blog/images/roll-change/5.jpg" alt="5"></p>
<p>为什么要分行来处理，因为行之间是互相独立的。你可以先把第一行的变换处理了，再继续把之后其他行的变换处理了。而你所得到的每行的几条弹幕，可以按照排列顺序把相同类型与长度的组合起来，因为它们互不影响，但是切记，保持每行所得到的弹幕结果的排列顺序。</p>
<p>无论如何，让我们先从第一行开始处理吧。</p>
<p><img src="/blog/images/roll-change/6.jpg" alt="6"></p>
<p>对于滚动MIKU的第一行来说，我们想要得到的是如图所示的变换效果。如何才能做到让各种长度的弹幕交错组合来达成这样的变化效果，接下来的是重头戏。</p>
<h2 id="三、变换原理">三、变换原理</h2><p>首先贴一张图。</p>
<p><img src="/blog/images/roll-change/7.jpg" alt="7"></p>
<p>这张图的意思是，对于12个字符这一基准长度，其余长度所对应的字符位置的变化方式。</p>
<p>还记不记得第一节最后的公式？</p>
<p>目标位置 = 基准位置 + ((目标长度 - 基准长度)  / 长度差)*（当前时间点 / 时间间隔）</p>
<p>你会发现，<strong>这些格子和其中的数字，就是以上这条公式的最直观表现（基准长度=12）</strong>。</p>
<p>接下来的图，是表明了某个长度中的某个位置的字符，是以怎样的轨迹移动的。</p>
<p><img src="/blog/images/roll-change/8.jpg" alt="8"></p>
<p>这张图的意思是，如果你在灰色格子中放入一个字符，这个字符在0.0s-4.0s这六个时间点上，将会以橙色格子的轨迹移动。</p>
<p>然后让我们把第二节和第三节的图对应起来。</p>
<p><img src="/blog/images/roll-change/9.png" alt="9"></p>
<p>是不是有种恍然大悟的感觉w<br>还是说“老早知道了混蛋！快点给我接着讲！”w</p>
<p>最后要说的，是变换的核心部分。</p>
<h2 id="四、变换解析">四、变换解析</h2><p><strong>滚动变换，说到底，是遮盖与显示互相交错的过程</strong>。</p>
<p><img src="/blog/images/roll-change/10.jpg" alt="10"></p>
<p>这张图是第二章中我说的，MIKU的第一行所要达到的目标。<br>可以看到，图中的空白部分，既可以没有弹幕，也可以用白色的弹幕遮盖。</p>
<p>而图中的蓝色部分，要以蓝色的弹幕来显示。</p>
<p>那么为了方便显示，</p>
<p>我以蓝灰色表示遮盖用的弹幕 ，</p>
<p>而以蓝色表示显示用的弹幕 。</p>
<p>而以蓝色、蓝灰色、白色所组成的方格 ，则表示需要被遮盖的位置。</p>
<p>这个位置的意义是，<strong>我需要一个显示字符来使变换过程完整，又要在0.8s的时候遮盖掉这个显示字符。</strong></p>
<p><img src="/blog/images/roll-change/11.jpg" alt="11"></p>
<p>这张图的意思是，先以蓝灰色完成目标长度为17的遮盖轨迹，如下图：</p>
<p><img src="/blog/images/roll-change/12.jpg" alt="12"> <img src="/blog/images/roll-change/13.jpg" alt="13"></p>
<p>再以蓝色完成目标长度为12的显示轨迹，如下图：</p>
<p><img src="/blog/images/roll-change/14.jpg" alt="14"> <img src="/blog/images/roll-change/15.jpg" alt="15"></p>
<p>为什么我能断言遮盖用的是长度为17的弹幕，而显示用的是长度为12的弹幕？因为字符移动的轨迹决定了我应该以哪一种弹幕来实现。这点可以参考一下第三节中的第二张图。</p>
<p>综上所述，要达成MIKU第一行的变换结果，请按照上面那两张图的灰色位置，以红色框为标准位置，再以使用的弹幕长度去查找第三节中的那张表。对应的图我截过来了，在上面的右侧。<br>你就会发现，遮盖使用的是17-6，而显示使用的是12-5。</p>
<p>于是第一次处理完成，现在的生成列表里有两条弹幕——<br>这是第一次生成，我给予它一个Lv0的编号。<br>！！注意：Lv0的弹幕处于所有“为了实现第一行所生成的”弹幕的最上层！！</p>
<p>遮盖生成的是17-6<br>意思是用透明方格生成一条最大长度为17个字符的弹幕<br>其中横向第6个位置有一个遮盖用的白色方格</p>
<p>显示生成的是12-5<br>意思是用透明方格生成一条最大长度为12个字符的弹幕<br>其中横向第5个位置有一个显示用的蓝色方格</p>
<p>那么第一次生成完毕后的结果如下图：</p>
<p><img src="/blog/images/roll-change/16.jpg" alt="16"></p>
<p>可以看到刚才生成的部分都被挖去了。这是因为接下来的弹幕都在刚才那两条的下面，所以即使再有显示用的弹幕经过刚才的位置也无所谓，都已经被前一条弹幕的轨迹给挡掉了。</p>
<p>以刚才的方法继续处理——</p>
<p><img src="/blog/images/roll-change/17.jpg" alt="17"></p>
<p>这回的结果如下——</p>
<p><strong>Lv1</strong></p>
<pre><code>遮盖生成的是7-6
显示生成的是12-8
</code></pre><p>那么生成列表里有四条弹幕了——</p>
<p><strong>Lv0</strong></p>
<pre><code>遮盖的17-6
显示的12-5
</code></pre><p><strong>Lv1</strong></p>
<pre><code>遮盖的7-6
显示的12-8
</code></pre><p>第二次生成完毕后的结果如下图：</p>
<p><img src="/blog/images/roll-change/18.jpg" alt="18"></p>
<p>那么剩余的我是以这样的方法实现的——</p>
<p><img src="/blog/images/roll-change/19.jpg" alt="19"></p>
<p>第三次：</p>
<p>Lv2</p>
<pre><code>遮盖生成的是12-8
显示生成的是2-2
</code></pre><p>第四次：</p>
<p>Lv3</p>
<pre><code>遮盖生成的是12-6
遮盖生成的是12-8
遮盖生成的是12-9
显示生成的是7-5
</code></pre><p>至此第一行的变换全部实现。现有的弹幕列表如下——</p>
<p>Lv0</p>
<pre><code>遮盖的17-6
显示的12-5
</code></pre><p>Lv1</p>
<pre><code>遮盖的7-6
显示的12-8
</code></pre><p>Lv2</p>
<pre><code>遮盖的12-8
显示的2-2
</code></pre><p>Lv3</p>
<pre><code>遮盖的12-6
遮盖的12-8
遮盖的12-9
显示的7-5
</code></pre><p>然后我们从上到下分析一下：</p>
<p>由于Lv0中已经存在了12-8，所以之下的所有Lv中12-8都可以删除<br>由于Lv3中三条都是长度为12的弹幕，可以将它们合并。<br>！！注意：同Lv的相同长度的弹幕才能合并！！</p>
<p>所以分析完成之后的弹幕列表如下——</p>
<p>Lv0</p>
<pre><code>遮盖的17-6
显示的12-5
</code></pre><p>Lv1</p>
<pre><code>遮盖的7-6
显示的12-8
</code></pre><p>Lv2</p>
<p>Lv3</p>
<pre><code>遮盖的12-6、9
显示的7-5
</code></pre><p>好，那么为了实现第一行的变换，我们需要如下的弹幕：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">“　　　　　█　　　　　　　　　　　” 白色</span><br><span class="line">“　　　　█　　　　　　　”              蓝色</span><br><span class="line">“　　　　　█　”                       白色</span><br><span class="line">“　　　　　　　　█　　　”              蓝色</span><br><span class="line">“　█”                                    蓝色</span><br><span class="line">“　　　　　█　　█　　　”              白色</span><br><span class="line">“　　　　█　　”                       蓝色</span><br></pre></td></tr></table></figure>
<p>然后说最后的注意事项——</p>
<p>因为，滚动变换中的弹幕都有着相同的出现时间，而XML读取器则是遵循“先读取先显示”的。所以最后创建的弹幕，才能遮盖掉先创建的弹幕。</p>
<p>也就是说，请自下而上地创建弹幕。即创建弹幕的顺序为生成顺序的逆转——</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">显示的<span class="number">7</span>-<span class="number">5</span>      “　　　　█　　”                       蓝色</span><br><span class="line">遮盖的<span class="number">12</span>-<span class="number">6</span>、<span class="number">9</span>   “　　　　　█　　█　　　”              白色</span><br><span class="line">显示的<span class="number">2</span>-<span class="number">2</span>      “　█”                                    蓝色</span><br><span class="line">显示的<span class="number">12</span>-<span class="number">8</span>     “　　　　　　　　█　　　”              蓝色</span><br><span class="line">遮盖的<span class="number">7</span>-<span class="number">6</span>      “　　　　　█　”                       白色</span><br><span class="line">显示的<span class="number">12</span>-<span class="number">5</span>     “　　　　█　　　　　　　”              蓝色</span><br><span class="line">遮盖的<span class="number">17</span>-<span class="number">6</span>     “　　　　　█　　　　　　　　　　　” 白色</span><br></pre></td></tr></table></figure>
<p>哎呀好像超过预计页数了的样子……</p>
<p>第一行的结果已经出来了。你们可以拿设计器v2去模拟，也可以自己写XML来模拟。不过现在只做了一行的滚动变换，虽然结果是正确的但是看上去很不爽对吧……于是你们可以按照以上的步骤，把第二节第二幅图中的全部五行都做出来……然后把弹幕合在一起。</p>
<p>！！这里还有个要点，行跟行之间的弹幕是没有任何关系的，你可以选择就这么直接叠加，也可以选择按照Lv的顺序将它们合并优化，这会很大程度上减少弹幕的数量，不过这不是必需的。暂时你们只要牢记每行的Lv不能改变就是了，如果愿意研究的可以自己试着去优化一下。！！</p>
<p>然后，你们就能看到一个自己做出来的MIKU滚动变换啦w</p>
<h2 id="五、结语">五、结语</h2><ul>
<li><p>总结一下要点吧。</p>
</li>
<li><p>首先数学很重要啊。</p>
</li>
<li><p>其次物理也很重要啊。</p>
</li>
<li><p>最后做弹幕的伤不起啊。</p>
</li>
</ul>
<p>好吧扯远了……</p>
<p>如果要做新的变换，比如汉字什么的。</p>
<pre><code>第零：请把理论完全掌握了……
第一：画出第二节的第一幅图样。
第二：画出第二节的第二幅图样。
第三：逐行生成弹幕。
第四：将每行生成出来的弹幕进行优化。
第五：合并所有行的弹幕并优化。
第结束：生成弹幕内容。
</code></pre><p>还有，刚才我所说的汉字的限制，请自行体会w</p>
<p>By Azure22 静之籁 2011/05/29</p>
<p>谨以本文纪念我去年的三个通宵。</p>
]]></content>
    <summary type="html">
    <![CDATA[早期的弹幕制作，有一个让人比较头疼的特效，就是普通弹幕滚动变换，这是关于其具体制作的原理。]]>
    
    </summary>
    
      <category term="Comment Art" scheme="http://ppii.in/blog/blog/tags/Comment-Art/"/>
    
      <category term="弹幕" scheme="http://ppii.in/blog/blog/tags/%E5%BC%B9%E5%B9%95/"/>
    
      <category term="弹幕艺术" scheme="http://ppii.in/blog/blog/categories/%E5%BC%B9%E5%B9%95%E8%89%BA%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ubuntu下遇到的find指令不存在的问题]]></title>
    <link href="http://ppii.in/blog/blog/2015/06/23/ubuntu-find/"/>
    <id>http://ppii.in/blog/blog/2015/06/23/ubuntu-find/</id>
    <published>2015-06-22T16:00:00.000Z</published>
    <updated>2015-06-22T15:13:32.742Z</updated>
    <content type="html"><![CDATA[<p>最近，在我的工作机器上，不知道出于何种原因，find指令出其地不存在？！导致不能新安装任何包。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dpkg: warning: 'find' <span class="keyword">not</span> found <span class="keyword">in</span> PATH <span class="keyword">or</span> <span class="keyword">not</span> executable</span><br><span class="line">dpkg: <span class="keyword">error</span>: <span class="number">1</span> expected program <span class="keyword">not</span> found <span class="keyword">in</span> PATH <span class="keyword">or</span> <span class="keyword">not</span> executable</span><br><span class="line">Note: root's PATH should usually <span class="keyword">contain</span> /usr/<span class="keyword">local</span>/sbin, /usr/sbin <span class="keyword">and</span> /sbin</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an <span class="keyword">error</span> code (<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>这还不是find的权限或者$PATH的问题。<a href="http://stackoverflow.com/questions/16597344/debian-aptitude-install-find-not-found-in-path-or-not-executable" target="_blank" rel="external">http://stackoverflow.com/questions/16597344/debian-aptitude-install-find-not-found-in-path-or-not-executable</a><br>搜了很多都没有找到相应的解决方案。</p>
<p>每次使用apt-get时候，都需要依靠find指令。然而我在寻找解决方案的过程中，而无论是使用，<code>apt-get install findutils --reinstall</code>还是直接安装<br><a href="https://launchpad.net/ubuntu/wily/i386/findutils/4.4.2-9build1" target="_blank" rel="external">findutils_4.4.2-9build1_i386.deb</a>都绕不开用到自身的find指令。要安装自己却要用到自己，这不是悖论吗？</p>
<p>就在我打算想办法用source code自行编译的时候，我无意中看到了这个指令”oldfind”，输入了，这个指令还真存在。。于是一句<code>ln -s /usr/bin/oldfind /usr/bin/find</code>死马当作活马医。</p>
<p>没想到，问题就这么解决了。。长时间受此煎熬，到现在我只想说一句：wpcap！</p>
<p>到底，还是太嫩。</p>
]]></content>
    <summary type="html">
    <![CDATA[oldfind和find的区别]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://ppii.in/blog/blog/tags/JavaScript/"/>
    
      <category term="技术问题" scheme="http://ppii.in/blog/blog/categories/%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[将博客从jekyll迁移到Hexo]]></title>
    <link href="http://ppii.in/blog/blog/2015/06/18/jekyll-to-hexo/"/>
    <id>http://ppii.in/blog/blog/2015/06/18/jekyll-to-hexo/</id>
    <published>2015-06-17T16:00:00.000Z</published>
    <updated>2015-07-11T14:19:03.732Z</updated>
    <content type="html"><![CDATA[<p>本博客建立之初，也只是能让自己能有一个合适的地方保存自己的学习笔记。并且Github天然地支持Markdown渲染，于是十分乐意地按照官方的教程基于jekyll搭建了这个博客。虽然很多时候没有阶段性地整理自己的学习历程（大部分笔记都放在了对应的repository里），不过免费不限流量的github博客也满足了我DIY的兴趣，所以也常不定期地写下一下学习笔记和文章。</p>
<p>具体迁移过程就不详述了，较为简单，以后有机会再自定义一些内容吧！</p>
<p>比较喜欢的两个主题<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">nexT</a> , <a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">yilia</a></p>
<p>有一个缺点就是，由于域名url的改变，以前的评论都不能对应起来了。</p>
<p><em>nexT的字色默认是#555显得有些泛白，阅读困难</em></p>
<p><a href="http://www.zhihu.com/question/24422335/answer/46357100" target="_blank" rel="external">参考资料</a></p>
<p><a href="http://zipperary.com/2013/05/30/hexo-guide-4/" target="_blank" rel="external">http://zipperary.com/2013/05/30/hexo-guide-4/</a></p>
<p><a href="https://github.com/iissnan/hexo-theme-next/wiki/%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next/wiki/%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2</a></p>
<p>过去的样式，截图留念。</p>
<p><img src="/blog/images/jekyll-to-hexo/1.jpg" alt="1"></p>
<p><img src="/blog/images/jekyll-to-hexo/2.jpg" alt="2"></p>
]]></content>
    <summary type="html">
    <![CDATA[博客系统，一切以实用为主。以呈现内容为主要目的]]>
    
    </summary>
    
      <category term="Hexo" scheme="http://ppii.in/blog/blog/tags/Hexo/"/>
    
      <category term="技术笔记" scheme="http://ppii.in/blog/blog/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++标准库算法遇到的一些问题]]></title>
    <link href="http://ppii.in/blog/blog/2015/05/23/generic-algorithm/"/>
    <id>http://ppii.in/blog/blog/2015/05/23/generic-algorithm/</id>
    <published>2015-05-22T16:00:00.000Z</published>
    <updated>2015-07-11T14:27:53.419Z</updated>
    <content type="html"><![CDATA[<p>什么是<strong>泛型编程</strong>：</p>
<p>简而言之，就是 <strong>用不变的代码实现可变的算法</strong>。</p>
<p>一般有以下几种应用：</p>
<ol>
<li>模板</li>
<li>RTTI（typeid, dynamic_cast, type_info）</li>
<li>虚函数</li>
</ol>
<p>理解C++泛型算法我注意的几点内容：</p>
<ol>
<li><p>除了algorithm中的一百多种算法， 头文件numeric中也定义了一组数值型泛型算法。</p>
</li>
<li><p>标准库算法不会改变它们操作的容器的大小，但是back_inserter却不然，原因是：</p>
</li>
</ol>
<p>严格来说，<strong>标准库算法根本不知道“容器”这个东西</strong>，它们只接受迭代器参数，运行于这些迭代器之上，通过迭代器访问元素。</p>
<p>当传递给算法普通迭代器时，普通的算法可以读取元素，改变元素值，移动元素，但是无法增加元素，删除元素。</p>
<p>但是传递给算法插入器的时候，（如back_inserter）,这类迭代器可以调用下层容器的操作来向容器插入元素，造成了增加元素的效果。</p>
<p>因此，问题的关键点是：标准库算法操作迭代器而间接访问容器，能不能增删元素，不在于算法，而在于传递给它们的迭代器是否具备这样的能力。</p>
<ol>
<li>lambda中，<code>-&gt; (return type)</code>的作用？</li>
</ol>
<p>假如lambda函数体内是单一的return语句，返回类型可以推断出来，无需指定。</p>
<p>假如lambda函数体内包含单一return语句之外的内容，且未指定返回类型，则返回void。</p>
<p><strong>假如，非单一return且未指定返回类型，但是返回了void之外的其他类型，会产生编译错误。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误：不能推断lambda返回类型。</span></span><br><span class="line">transform(v.begin(), v.end(), v.begin(), [](<span class="keyword">int</span> i) &#123; <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i;&#125;);</span><br><span class="line"><span class="comment">//正确：</span></span><br><span class="line">transform(v.begin(), v.end(), v.begin(), [](<span class="keyword">int</span> i) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i;&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>然而，我<a href="https://github.com/Miantang/PAT/blob/master/NowCoder-Practice/1002-2.cpp" target="_blank" rel="external">这段程序</a>不管指定int,bool,或者不指定，都不报错但报warning，原因？</strong></p>
<blockquote>
<p>warning: control reaches end of non-void function [-Wreturn-type]</p>
</blockquote>
<p><a href="http://www.nowcoder.com/pat/1/problem/4015" target="_blank" rel="external">对应的相关题目</a></p>
<p>经过<a href="https://blog.a-kar.in/legacy-mode8-projects/" target="_blank" rel="external">EPM God</a>的提点，我这个warning是因为 int 的遍历不全。<br>（虽然跟C++ Primer上说的，会报错但是实际没报错，不知道是不是编译器(MinGW 4.8.1)的关系</p>
<ol>
<li>lambda中的捕获，</li>
</ol>
<p>捕获列表只用于局部非static变量，lambda可以直接使用局部static变量和所在函数之外声明的名字。</p>
<p>为避免潜在的捕获导致的问题，可能的话，应该避免捕获指针和引用。</p>
<p>[=] ： 隐式捕获，引用捕获。</p>
<p>[&amp;, a, b…] : <code>a,b</code>表示这些变量采用值捕获，而其他任何隐式捕获采用引用捕获。</p>
<p>[=, a, b…] : <code>a,b</code>表示这些变量采用引用捕获，而其他任何隐式捕获采用值捕获。</p>
]]></content>
    <summary type="html">
    <![CDATA[需要深入理解“泛型”的思想，体会标准库是如何通过算法和数据结构的分离来实现泛型，迭代器是如何在这两者之间架起的桥梁。]]>
    
    </summary>
    
      <category term="编程学习" scheme="http://ppii.in/blog/blog/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="技术问题" scheme="http://ppii.in/blog/blog/categories/%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[物联网关于硬件平台/协议的原型设计]]></title>
    <link href="http://ppii.in/blog/blog/2015/04/23/iot-origin/"/>
    <id>http://ppii.in/blog/blog/2015/04/23/iot-origin/</id>
    <published>2015-04-22T16:00:00.000Z</published>
    <updated>2015-07-11T14:27:53.417Z</updated>
    <content type="html"><![CDATA[<h2 id="1-_硬件平台">1. 硬件平台</h2><p>物联网系统设计现如今已经有着众多的技术方案，各有各的特色/优点和使用场景。</p>
<p>假如以成本来考虑，可能有以下一些方案：</p>
<ul>
<li><p>51单片机，AVR单片机，430单片机，芯片价格较为便宜，假如不是很依靠操作系统，仅为了解决一部分简单/特定的需求，这种方式可以考虑。但是涉及到IO控制/驱动/代码写入等等问题，并不能算是一种快速的解决方案。</p>
</li>
<li><p>Arduino或者Arduino的扩展平台。虽然大部分也是使用的是AVR微处理芯片，但是作为开源硬件，已经很好的提供较为完善的整套开发流程，如IO标签，IDE，对于一些常见场景，都能找到较为完善的解决方案，同时也有着活跃的交流社区。不过出于性能和内存考虑，要使用类C的Processing语言编程。</p>
</li>
<li><p>一些诸如BeagleBone/树莓派的开发板，它们有着相对更强大的处理能力和足够大的RAM，同时运行Linux，它们可以使用更多高级的编程语言，如Python/JavaScript，在基于Web服务器诸如nginx/Node.js等平台，因为已经有现成的库，对于直接控制IO引脚也是十分方便。</p>
</li>
<li><p>……</p>
</li>
</ul>
<h2 id="2-_协议选型">2. 协议选型</h2><h3 id="1)_HTTP">1) HTTP</h3><p>采用HTTP方案，向HTTP服务器发送HTTP请求，能从服务器接收到响应，假如对实时响应要求高，那么采用这种方案并不科学。建立一次HTTP请求需要在下位机和服务器之间建立好几个来回的交互（三次握手），对于Arduino来说，当前的以太网在建立http连接时，会阻塞其他操作，这意味着在这段时间内，处理器不能做其他操作（尽管用硬件中断可以相应解决这个问题，但这使问题复杂化并且加入了一些不必要的限制）。鉴于此，对于一些对实时性要求不高的系统，比如长时监控，可以考虑这种解决方案。</p>
<h3 id="2）长轮询。">2）长轮询。</h3><p>这意味服务器必须周期性地向客户端发送keep-alive消息，防止物联网下级装置认为服务器超时无响应，并且，最大的缺点还是，单向通信。</p>
<h3 id="3）WebSockets">3）WebSockets</h3><p>在HTML5标准提出后，很有效地解决了一部分HTTP协议的缺点。优势就是可以双向通信，在Arduino中有一个（部分）实现的WebSockets库.<a href="https://github.com/krohling/ArduinoWebsocketClient" target="_blank" rel="external">https://github.com/krohling/ArduinoWebsocketClient</a></p>
<p>但是由于技术方案较新，实现上有待商榷。</p>
<h3 id="4）MQTT">4）MQTT</h3><p>消息队列遥测传输，是一种轻量级的消息传输协议，专门针对网络带宽受限或者代码的内存占有量有限的应用场景设计而成。</p>
<p>不同于HTTP采用客户端/服务器模型，MQTT使用的是发布/订阅机制，实现了经由消息代理的消息交换。发送者与接收者通信依靠的是相应的消息主题。在及时性和双向通信上有着很不错的表现。同时，它消除了存在于HTTP中客户端和服务器的紧密耦合。</p>
<p>同时MQTT可以运用与许多非常受限的平台和网络环境，诸如zigbee等传感器网络。</p>
<h3 id="5）XMPP">5）XMPP</h3><p>是另一种消息传输的解决方案。可扩展通讯和表示协议。是因特网上一种较为通用的协议，采用XML作为消息格式。由于消息可能相对冗长，可能不太适用于内存受限的微处理器。</p>
<h3 id="6）CoAP">6）CoAP</h3><p>设计受限应用协议。旨在解决适用于HTTP的同类问题。类似与MQTT-S，可以用于没有TCP的网络。</p>
]]></content>
    <summary type="html">
    <![CDATA[起初的原型设计，包括硬件平台/协议选型，都关系到后期整个项目的进展。]]>
    
    </summary>
    
      <category term="物联网" scheme="http://ppii.in/blog/blog/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
      <category term="物联网" scheme="http://ppii.in/blog/blog/categories/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Does C support function overloading like C++?]]></title>
    <link href="http://ppii.in/blog/blog/2015/04/03/cpp-learning/"/>
    <id>http://ppii.in/blog/blog/2015/04/03/cpp-learning/</id>
    <published>2015-04-02T16:00:00.000Z</published>
    <updated>2015-06-22T15:13:32.742Z</updated>
    <content type="html"><![CDATA[<p>If you consider theprintf() function in C, that may lead you to think that C supports function overloading. Because, in C you can have <code>printf(&quot;%d&quot;, aDecimal)</code> and <code>printf(&quot;%f&quot;, aFloat)</code>. This looks a lot like function overloading, because we are using the same function name, but the function is accepting different parameter types – which is one of the ways we can overload functions.</p>
<h3 id="A_Variable_Argument_List_is_not_Function_Overloading">A Variable Argument List is not Function Overloading</h3><p>Actually, this is not a case of function overloading – the printf function is just using a feature of C known as variable argument lists. This should not be confused with function overloading. So, to answer the question, Standard C does not support function overloading.</p>
<p>As an interesting side note, C++ doesn’t really have function overloading. What it does have is a means of faking it: the C++ compiler actually ‘mangles’ (or changes) function names according to the function’s parameters. So, functions that share the same name but have different numbers or types of parameters can be differentiated when invoked. Also, since the ‘mangling’ of function names is not standardized, it’s usually difficult to link object files compiled by different C++ compilers.</p>
<p> <a href="http://www.programmerinterview.com/index.php/c-cplusplus/function-overloading/" target="_blank" rel="external">.</a></p>
]]></content>
    <summary type="html">
    <![CDATA[A Variable Argument List is not Function Overloading]]>
    
    </summary>
    
      <category term="编程学习" scheme="http://ppii.in/blog/blog/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="技术问题" scheme="http://ppii.in/blog/blog/categories/%E6%8A%80%E6%9C%AF%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉树的后序非递归遍历]]></title>
    <link href="http://ppii.in/blog/blog/2015/01/03/bintree-postoder/"/>
    <id>http://ppii.in/blog/blog/2015/01/03/bintree-postoder/</id>
    <published>2015-01-02T16:00:00.000Z</published>
    <updated>2015-07-11T14:27:53.415Z</updated>
    <content type="html"><![CDATA[<p>二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。对于二叉树，有前序、中序以及后序三种遍历方法。因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁。而对于树的遍历若采用非递归的方法，就要采用栈去模拟实现。在三种遍历中，前序和中序遍历的非递归算法都很容易实现，非递归后序遍历实现起来相对来说要难一点。</p>
<h3 id="后序遍历">后序遍历</h3><p><strong>后序遍历按照“左孩子-右孩子-根结点”的顺序进行访问。</strong></p>
<h4 id="递归实现">递归实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder1</span><span class="params">(BinTree *root)</span>    <span class="comment">//递归后序遍历</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        postOrder1(root-&gt;lchild);</span><br><span class="line">        postOrder1(root-&gt;rchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;root-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="非递归实现">非递归实现</h4><p>这里要保证左子和右子都已经被访问之后，并且左子在右子前访问，才能访问根节点。就这对流程有较大的影响。</p>
<p>这里根据查阅资料提供两个思路：</p>
<p> 第一种思路：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该结点是否是第一次出现在栈顶。</p>
<p> 第二种思路：要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。</p>
<p><a href="http://www.cnblogs.com/dolphin0520/archive/2011/08/25/2153720.html" target="_blank" rel="external">`</a></p>
]]></content>
    <summary type="html">
    <![CDATA[二叉树作为一种十分重要的数据结构，基本的遍历方式有三种，先序，中序，后序。一般可以用递归的形式来遍历。而非递归则需要采用堆栈俩模拟，其中先序和中序较好实现，但后序相对会难点。]]>
    
    </summary>
    
      <category term="编程学习" scheme="http://ppii.in/blog/blog/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="技术笔记" scheme="http://ppii.in/blog/blog/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2014-12-11_20日志]]></title>
    <link href="http://ppii.in/blog/blog/2014/12/20/diary10/"/>
    <id>http://ppii.in/blog/blog/2014/12/20/diary10/</id>
    <published>2014-12-19T16:00:00.000Z</published>
    <updated>2015-06-22T15:13:32.742Z</updated>
    <content type="html"><![CDATA[<p>虽然说，最近因为考试也好，各种杂事也好。但这些都不能是我作为暂停写日志的因素。有的时候会看书，学MOOC坚持到很晚将近一点。困了累了就不想打开记事本写下这个每日的总结和感想，包括对李笑来老师的《把时间当朋友》的认真研读也被搁置了。</p>
<p>果然还是自己的执行力上，养成这样一个习惯，并不是很简单。有的时候只是一念之间。应该还是认识不够。要是我再不写下，也许多少个月就过去了。</p>
<p>26号，30号两门专业课的考试。不能再吐槽它们的作用，以及研究生的专业课是否对自己的研究方向有作用。该遇到的，总是要解决。不能质疑任何知识的作用。即使这辈子十分大的可能不再用上。但是这是毕业必需的。所以还是要好好准备考试。</p>
<p>今天刚刚考完六级，苦于没有好好准备，其实还是往常的做英语的状态。没有那种得心应手的感觉，信息获取效率还是很低。阅读一篇英语文章，不能很好的理解真实的内容。虽然是六级刷分，没有什么压力感。。不过这次机会还是没有好好把握住。研究生阶段也就剩下明年的六月的这次六级考试了。好好准备吧。</p>
<p>还有两篇论文，明天一定要完成一篇才行啊。哎。越到期末，各种各样的事情全部蜂拥而至，并且越忙，自己想学的东西就越多。。去图书馆又借了大量的新书。希望会是考完之后好好补一补计算机知识。年年复年年都是这个状态呢。</p>
<p>MOOC可能会落下几门课。不够很多还是没有时间做作业，毕竟期末才是重要的。重点抓好浙江大学的那门数据结构和哈工大的算法导论吧。当务之急！</p>
<p>不管是怎么样，想好好改一下，做总结，写日志，做笔记的形式。但是不能在策划好整个方法之前，什么事情都不做。先做，慢慢再去完善。这是我最应该认识到的！</p>
]]></content>
    <summary type="html">
    <![CDATA[执行力差。害怕失败，追求完美。关键的问题，还是贵在坚持。]]>
    
    </summary>
    
      <category term="日记" scheme="http://ppii.in/blog/blog/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="心情笔记" scheme="http://ppii.in/blog/blog/categories/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2014-12-10-日志]]></title>
    <link href="http://ppii.in/blog/blog/2014/12/10/diary8/"/>
    <id>http://ppii.in/blog/blog/2014/12/10/diary8/</id>
    <published>2014-12-09T16:00:00.000Z</published>
    <updated>2015-06-22T15:13:32.742Z</updated>
    <content type="html"><![CDATA[<p>现代信号处理，这门课还好去了，课堂上考了一个试。题目虽然只有两道，还是不太会做啊。某种程度上还是自己根本没有好好复习。要考试了，考前焦虑又来了。大约会在12月27号考试，看来这个很需要好好计划一番啊。</p>
<p>明天开始尝试写下自己的时间账本。寻找一种更好，更一目了然可以回溯查看的方法。</p>
<p>特别是MOOC的内容，还是有一个好规划才行。不然每天挺盲目的。</p>
<p>信号检测的报告还没写。还有相应的PPT……这是一个大坑。这周之内要完成啊。。</p>
<p>fight！</p>
]]></content>
    <summary type="html">
    <![CDATA[要开始考试了，时间上开始紧凑！时间管理！信号检测的报告还没有写。多件事情，让我显得有些焦虑。]]>
    
    </summary>
    
      <category term="日记" scheme="http://ppii.in/blog/blog/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="心情笔记" scheme="http://ppii.in/blog/blog/categories/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2014-12-09-日志]]></title>
    <link href="http://ppii.in/blog/blog/2014/12/09/diary7/"/>
    <id>http://ppii.in/blog/blog/2014/12/09/diary7/</id>
    <published>2014-12-08T16:00:00.000Z</published>
    <updated>2015-06-22T15:13:32.742Z</updated>
    <content type="html"><![CDATA[<p>开启了你的梦想吗。阅读了新东方李笑来老师的《把时间当朋友》，里面提到了一种关于时间记录的方法，Event-log。把我一天的时间消耗全部记录下来，不写感想不写结果，只写做了什么。一目了然，等一段时间之后，就会发现，自己无意义的事情会越来越少。以后做的事情也是越来越有意义的。这一点，跟<a href="http://www.zhihu.com/question/21438053" target="_blank" rel="external">学习编程用什么做笔记比较好？</a>,<a href="http://www.zhihu.com/question/23427617" target="_blank" rel="external">如何构建你的笔记系统？</a>。有着异曲同工的相同之处。</p>
<p><strong>关键还是好记性不如烂笔头啊。。你要记住你所浪费的时间！你浪费了多少时间！</strong></p>
<p>最近学习JAVA和安卓，倒是想能在明年4月之前，看能不能开发出这样一个APP。</p>
<p>以此为目标和动力尝试一下吧！先把整体软件的功能架构写出来~参考一下同类的软件。</p>
]]></content>
    <summary type="html">
    <![CDATA[一种高效的时间管理方法，有了写一个时间账本APP的想法]]>
    
    </summary>
    
      <category term="日记" scheme="http://ppii.in/blog/blog/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="心情笔记" scheme="http://ppii.in/blog/blog/categories/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2014-12-08-日志]]></title>
    <link href="http://ppii.in/blog/blog/2014/12/08/diary6/"/>
    <id>http://ppii.in/blog/blog/2014/12/08/diary6/</id>
    <published>2014-12-07T16:00:00.000Z</published>
    <updated>2015-06-22T15:13:32.742Z</updated>
    <content type="html"><![CDATA[<p>确定要开始考试了！12月20日。信号检测与估计。</p>
<p>时间管理！现在一周过去已经感觉到一点吃力了。</p>
<p>北理工那门《面向对象编程实训》有点吃力。毕竟Winform控件还没入门。很多东西都不太会写。作业虽然基本功能实现了。但是代码实在，，难看啊。</p>
<p>写好我的计划表。不能放弃任何一个小时。</p>
<p>Do！</p>
]]></content>
    <summary type="html">
    <![CDATA[要开始考试了，时间上开始紧凑！时间管理！]]>
    
    </summary>
    
      <category term="github" scheme="http://ppii.in/blog/blog/tags/github/"/>
    
      <category term="日记" scheme="http://ppii.in/blog/blog/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="心情笔记" scheme="http://ppii.in/blog/blog/categories/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2014-12-07-日志]]></title>
    <link href="http://ppii.in/blog/blog/2014/12/07/diary5/"/>
    <id>http://ppii.in/blog/blog/2014/12/07/diary5/</id>
    <published>2014-12-06T16:00:00.000Z</published>
    <updated>2015-06-22T15:13:32.726Z</updated>
    <content type="html"><![CDATA[<p>整理了一下网易云课堂的内容，十门课啊。后期可能会很吃力。。看来时间管理很重要。。想看看自己的极限在哪里。我希望可以全部拿到证书（有可能是一个奢望）。</p>
<p>导师又再次强调了理论的重要性。智能家居这个项目的投标阶段将要结束。下一个项目“干扰性能评估系统”要到来了！需要好好准备C++，MFC和MATLAB吧，可能主要还是理论算法上的积淀。等今后老师的交接吧。</p>
<p>今天还把明天《科研信息获取与利用》这门课的PPT做完了。80多页。。作为组长伤不起啊。组员很多都比较敷衍了事，虽然整个内容不是很重要，主要在检索的过程。漏洞太多，我也不能全部修复，只能在明天做presention的时候现场发挥了。加油！</p>
]]></content>
    <summary type="html">
    <![CDATA[周末休息]]>
    
    </summary>
    
      <category term="github" scheme="http://ppii.in/blog/blog/tags/github/"/>
    
      <category term="日记" scheme="http://ppii.in/blog/blog/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="心情笔记" scheme="http://ppii.in/blog/blog/categories/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2014-12-06-日志]]></title>
    <link href="http://ppii.in/blog/blog/2014/12/06/diary4/"/>
    <id>http://ppii.in/blog/blog/2014/12/06/diary4/</id>
    <published>2014-12-05T16:00:00.000Z</published>
    <updated>2015-06-22T15:13:32.726Z</updated>
    <content type="html"><![CDATA[<p>今天算是修复了github的blog上一点css的错乱问题。</p>
<p>整理了一下印象笔记的内容。把网易云课堂的课程进度同步在印象笔记。<br>为知笔记出乎意料的好，保存网页十分保真。这一点可能有道云笔记感觉逊色一些。<br>三个笔记配合着使用吧！</p>
]]></content>
    <summary type="html">
    <![CDATA[周末休息]]>
    
    </summary>
    
      <category term="github" scheme="http://ppii.in/blog/blog/tags/github/"/>
    
      <category term="日记" scheme="http://ppii.in/blog/blog/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="心情笔记" scheme="http://ppii.in/blog/blog/categories/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2014-12-05-日志]]></title>
    <link href="http://ppii.in/blog/blog/2014/12/05/diary3/"/>
    <id>http://ppii.in/blog/blog/2014/12/05/diary3/</id>
    <published>2014-12-04T16:00:00.000Z</published>
    <updated>2015-06-22T15:13:32.726Z</updated>
    <content type="html"><![CDATA[<p>今晚刷了好几门课程。包括，编译原理，C、Python，做了相关的课后习题。太晚了，今天的留在明天早上来总结吧。晚安先~</p>
<p>上午上的学术英语课，我争取到机会，终于可以上讲台进行自己的presentation。好几周之前已经准备好的PPT了。对一篇国际会议论文进行阐述。同时陈述自己的看法。<br>我选择的课题是，统计分析下认提对可穿戴天线的影响。TODO</p>
<p>当然说最后留下的感受吧。<br>自己还是有演讲焦虑，在没有充分准备的情况下（因为ppt很久之前做的，很多忘了），说话会磕巴，紧张。有的时候并不能表述清楚自己的观点。演讲还是需要有一个明晰的脉络才不至于手忙脚乱语无伦次。当然，有的情况下，我的自我发挥还是有可取之处。包括中途提到的一些例子，都是临时想的。<br>在台下也“臆想”了自己怎么讲讲讲，会讲成什么样，到头来很多都没有达到预期。也给自己太大的压力了。</p>
<p> <strong>所以，在做任何事情之前，准备好，确立一个清晰的脉络。肚子里有货，才会不慌张</strong></p>
<p>另外一点，就是在自学课程上，有一个明晰的计划任务，不至于在一些简单的问题上花费大量的时间，也不至于在一些较为困难的问题上失去准心，不知道如何下手。<strong>多思考，打好基础才是最重要的</strong>。</p>
<p>还是那个观点，到中期，课程的紧张不一定会让自己有足够的精力完成这些事情。那个时候会很吃力。注意好优先级，提高笔记能力，学习的效率，以赛代练！早点能确立相关的课题。</p>
<p>导师今天给我们的说法是，明年他的看法是以写文章为主。因为项目足够多，还需要一些理论上的沉淀。<br>我知道，这个对于我这个两年制的专业硕士来说，是很冲突的，包括自己的未来目标，以及专业硕士的培养要求，这些都不是我必需的。而我自己在这方面可能也有不足，比如，前段时间导师让我写的专利起底。其实很多情况下，我并不能高屋建瓴地在这个特定的专业领域做相关的创新点设计。所以那个月还是很没有成就感的，比较低落。还是一个实际的工程项目会让我有很强大的动力去完成。<br>求同存异了吧。就怕明年实习导师肯定不会让我出去。</p>
<p><em>有时间把blog重新启用一下，每天的post都push到blog上。</em></p>
]]></content>
    <summary type="html">
    <![CDATA[学术英语课上，我的presentation，给我留下的什么经验，以及自己在公众演讲上的不足；课程学习内容很多，学会把时间分配好；研究生阶段与导师的目标有冲突的情况下，求同存异。]]>
    
    </summary>
    
      <category term="日记" scheme="http://ppii.in/blog/blog/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="网易云课堂" scheme="http://ppii.in/blog/blog/tags/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82/"/>
    
      <category term="心情笔记" scheme="http://ppii.in/blog/blog/categories/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2014-12-04-日志]]></title>
    <link href="http://ppii.in/blog/blog/2014/12/04/diary2/"/>
    <id>http://ppii.in/blog/blog/2014/12/04/diary2/</id>
    <published>2014-12-03T16:00:00.000Z</published>
    <updated>2015-06-22T15:13:32.726Z</updated>
    <content type="html"><![CDATA[<p><strong>坚持不可谓不是一件考验毅力的事情。</strong></p>
<p>今天《现代信号处理》的冯老师出差，这节课就没有上。一天的时间可以说是泡在实验室。继续与同门小伙伴一起探讨关于导师项目的方案，头脑风暴多次，也只是得出一些简单的结论。今天也求助了网络上的软件工程专业的朋友，关于写这个项目的安卓app的难度。其实自己对整个框架和实现方法还是有一个大致的雏形。只是苦于入门不深，还是不够自信。导师还请了计算机系的外援，到后来经过一番讨论确立了一个大致的方案发现，其实难度上并不是在安卓app端的控制，而是中心服务器的架构上。导师笑称，我们给他造成了一个困难局面的假象。到头来还请了外援，不上不下的。</p>
<p>总结今天这个事情来说，还是需要多多涉猎各方面的知识啊。才能做出合理的判断。（不过，后期懂得更多的时候，也许现在的判断也会被推翻。螺旋式上升的过程~）</p>
<p>另外一方面，关于网易云课堂，今天没有花费时间来学习，总感觉是不妥的，这个还是不能停的。毕竟是有期限的。明天最好能做出一个周计划表，以防止中途忘记更新课程的学习而失去了机会。到头来还是坚持的问题啊。</p>
<p>刷了挺久的知乎，到底能从里面得到什么？我认为还是需要多花时间消化一下收藏夹的内容。有的时候，什么都想知道一点，其实就是什么都不知道。做笔记也好，markdown也好，关键是以用为主。比如说现在写的日志，关键是要为以后留下什么经验或者教训，以警示今后不再犯错误，坚持好的方面等等。</p>
<p>这方面是任重道远啊！</p>
<p>0点55.早点休息吧，晚安！每天对着亲爱的，说晚安，其实已经是两个小时之前了。哎。时间利用的效率啊，难怪会经常焦虑。</p>
]]></content>
    <summary type="html">
    <![CDATA[现代信号处理也好，网易云课堂也好，关键是利用好时间，做好时间管理。明确自己的目标，计划，学习牛人的经验，学会做笔记，学会收藏，学会消化优秀的经验，学会学以致用！ ]]>
    
    </summary>
    
      <category term="日记" scheme="http://ppii.in/blog/blog/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="网易云课堂" scheme="http://ppii.in/blog/blog/tags/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82/"/>
    
      <category term="心情笔记" scheme="http://ppii.in/blog/blog/categories/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2014-12-03-日志]]></title>
    <link href="http://ppii.in/blog/blog/2014/12/03/diary1/"/>
    <id>http://ppii.in/blog/blog/2014/12/03/diary1/</id>
    <published>2014-12-02T16:00:00.000Z</published>
    <updated>2015-06-22T15:13:32.726Z</updated>
    <content type="html"><![CDATA[<p>今天是写日志的第一天。<br>在这里先给自己一些简单的要求：（以后可以继续补充）</p>
<blockquote>
<ul>
<li>尝试之后的git，push上我的jekyll博客。<ul>
<li>每次写完之后记得做一次description，锻炼自己的概括能力。</li>
</ul>
</li>
<li>每次的撰写时间尽量要短。不能吭哧瘪肚很久才吐出一点来。</li>
<li>严格按照计算机指法吧，计算机键盘盲打的重要性，这也是从《把时间当朋友》这本书中得出的tip。就算是以后coding的时候，这种能力还是至关重要的。</li>
<li>TODO</li>
</ul>
</blockquote>
<p> 昨晚睡得比较晚，早上晚起太多，偷了一上午懒没有去实验室。有点自责。</p>
<p> 今天上的《信号检测与估计理论》，基本上还是没有多听得懂。看来需要集中时间把落下的知识恶补一下。<br> 导师要求我们把“智能家居”这个项目整理出一个可行的方案。虽然现在关于Android的app是我们比较吃力的部分。因为毕竟是属于纯计算机方向的能力了。怎么说吧，事在人为，肯定是能写出来的。</p>
<p> 今天算是坚持下来网易云课堂的第三天，暂时上了三门课，《算法导论》、《C编程实践》、《数据结构》。虽然12月1日开了八门课，但是肯定也不能全部吃下来。雄心壮志般想在满足导师任务、两门超难的专业课、还自学坚持下这些计算机课程。的确需要不小的毅力。特别是持之以恒以及高效率的学习模式这两点。</p>
<p> 数据结构这门课，初上的感觉还不错，浙江大学陈越老师真的讲的挺好。另外有一点令我十分震惊的是，参加这门课的人数之多，每道题的讨论区超过500楼，PAT的代码提交数这四天内也已经超过2000。比如那道“中等数量级的图书应该怎样排序的问题”，讨论区中也有许多同学提到了我不理解的诸如hash、散列等高端的解决办法，他们可能是来复习的吧。不过这也表示我还有很多我需要学习的地方。努力坚持吧！</p>
<p> 真不知道自己能不能处理好时间上的分配。特别是到了云课堂的中期，那时候还是项目重要时期，更是两门专业课的重要结课期，能不能坚持下MOOC还是看自己现在开始的提前准备了。。Keep moving！还有一个六级。。哎<br> PS：这个月已经成为知乎重度用户了啊。。虽然在自己关注的领域，还一直是一个小白，成为一位优秀的答题者看来也还不够。以这个为目标！发现知乎也在不知不觉改变我的价值观！</p>
<p> 记一篇TED视频：<a href="http://www.56.com/u65/v_MTE2MTQyNTQy.html" target="_blank" rel="external">The First 20 Hours_ How to Learn Anything</a> </p>
<p> 和一条知乎问题: <a href="http://www.zhihu.com/question/23427617" target="_blank" rel="external">如何构建你的笔记系统？</a></p>
]]></content>
    <summary type="html">
    <![CDATA[第一天的日志。]]>
    
    </summary>
    
      <category term="日记" scheme="http://ppii.in/blog/blog/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="网易云课堂" scheme="http://ppii.in/blog/blog/tags/%E7%BD%91%E6%98%93%E4%BA%91%E8%AF%BE%E5%A0%82/"/>
    
      <category term="心情笔记" scheme="http://ppii.in/blog/blog/categories/%E5%BF%83%E6%83%85%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[亲爱的安德烈]]></title>
    <link href="http://ppii.in/blog/blog/2014/09/07/andreas/"/>
    <id>http://ppii.in/blog/blog/2014/09/07/andreas/</id>
    <published>2014-09-06T16:00:00.000Z</published>
    <updated>2015-06-22T15:13:32.726Z</updated>
    <content type="html"><![CDATA[<p>人生，其实像一条从宽阔的平原走进森林的路。在平原上同伴可以结伙而行，欢乐地前推后挤、相濡以沫；一旦进入森林，草丛和荆棘挡路，各人专心走各人的路，寻找各人的方向，那推推挤挤的群体情感，那无忧无虑无猜忌的同侪深情，在人的一生中也只有少年期有。离开这段纯洁而明亮的阶段，路其实可能愈走愈孤独。你将被家庭羁绊，被责任捆绑，被自己的野心套牢，被人生的复杂和矛盾压抑，你往丛林深处走去，愈走愈深，不复再有阳光似的伙伴。到了熟透的年龄，即使在群众的怀抱中，你都可能觉得寂寞无比</p>
<p>……</p>
]]></content>
    <summary type="html">
    <![CDATA[亲爱的安德烈 读后感]]>
    
    </summary>
    
      <category term="书评" scheme="http://ppii.in/blog/blog/tags/%E4%B9%A6%E8%AF%84/"/>
    
      <category term="人文笔记" scheme="http://ppii.in/blog/blog/categories/%E4%BA%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Git时代的VIM不完全使用教程]]></title>
    <link href="http://ppii.in/blog/blog/2014/07/26/vimtutor/"/>
    <id>http://ppii.in/blog/blog/2014/07/26/vimtutor/</id>
    <published>2014-07-25T16:00:00.000Z</published>
    <updated>2015-06-23T15:39:57.902Z</updated>
    <content type="html"><![CDATA[<p>最近整理了VIM的配置，换上插件管理的神器——-<a href="https://github.com/gmarik/vundle" target="_blank" rel="external">Vundle</a>，由他引发的VIM生态环境的改善，堪称完美。遂打算写一份简单的教程，分享Git时代VIM新世界的美丽动人之处。<strong>对VIM有基础的同学，可直接跳至插件管理部分。</strong></p>
<h2 id="VIM的模式">VIM的模式</h2><p>第一次使用VIM，会觉得无所适从，他并不像记事本，你敲什么键就显示什么，理解VIM的需要明白他的两种模式：</p>
<ul>
<li>命令模式 (Command Mode)</li>
<li>编辑模式 (Insert Mode)</li>
</ul>
<p>命令模式下，可以做移动、编辑操作；编辑模式则用来输入。键入<code>i</code>,<code>o</code>,<code>s</code>,<code>a</code>等即可进入编辑模式，后面解释原因。</p>
<p>模式的设计是VIM和其他编辑器最不同的地方，优势和劣势也全基于此而生。</p>
<h2 id="基本操作">基本操作</h2><p>以下介绍的键盘操作，都是大小写敏感的，并且要在<strong>命令模式</strong>下完成，需注意：</p>
<h3 id="以字为单位的移动">以字为单位的移动</h3><ul>
<li><code>h</code> 向左移动一个字</li>
<li><code>j</code> 向下移动一行</li>
<li><code>k</code> 向上</li>
<li><code>l</code> 向右</li>
</ul>
<p>这四个键在右手最容易碰到几个位置，最为常用。</p>
<h3 id="以词为单位的移动">以词为单位的移动</h3><ul>
<li><code>w</code> 下一個word w(ord)</li>
<li><code>W</code> 下一個word(跳过标点)</li>
<li><code>b</code> 前一個word b(ackward)</li>
<li><code>B</code> 前一个word(跳过标点)</li>
<li><code>e</code> 跳到当前word的尾端 e(nd)</li>
</ul>
<h3 id="行移动">行移动</h3><ul>
<li><code>0</code> 跳到当前行的开头</li>
<li><code>^</code> 跳到当前行第一个非空字符</li>
<li><code>$</code> 跳到行尾</li>
</ul>
<p>助记：0(第0个字符),<code>^</code>和<code>$</code>含义同正则表达式</p>
<h3 id="段落移动">段落移动</h3><ul>
<li><code>{</code> 上一段(以空白行分隔)</li>
<li><code>}</code> 下一段(以空白行分隔)</li>
<li><code>%</code> 跳到当前对应的括号上(适用各种配对符号)</li>
</ul>
<h3 id="跳跃移动">跳跃移动</h3><ul>
<li><code>/xxxx</code> 搜索xxxx，然后可以用<code>n</code>下一个，<code>N</code>上一个移动</li>
<li><code>#</code> 向前搜索光标当前所在的字</li>
<li><code>*</code> 向后搜索光标当前所在的字</li>
<li><code>fx</code> 在当前行移动到光标之后第一个字符x的位置 f(ind)x</li>
<li><code>gd</code> 跳到光标所在位置词(word)的定义位置 g(o)d(efine)</li>
<li><code>gg</code> 到文档顶部</li>
<li><code>G</code> 到文档底部</li>
<li><code>:x</code> 跳到第x行(x是行号)</li>
<li><code>ctrl+d</code> 向下翻页 d(down)</li>
<li><code>ctrl+u</code> 向上翻页 u(p)</li>
</ul>
<h3 id="基本编辑">基本编辑</h3><h4 id="修改">修改</h4><ul>
<li><code>i</code> 在光标当前位置向前插入 i(nsert)</li>
<li><code>I</code> 在本行第一个字符前插入</li>
<li><code>a</code> 在光标当前位置向后插入 a(fter)</li>
<li><code>A</code> 在本行末尾插入</li>
<li><code>o</code> 向下插入一行</li>
<li><code>O</code> 向上插入一行</li>
<li><code>:w</code> 保存</li>
<li><code>:q</code> 退出</li>
<li><code>:wq</code> 保存并退出</li>
</ul>
<h4 id="删除">删除</h4><ul>
<li><code>x</code> 删除当前字符</li>
<li><code>dd</code> 删除当前行 d(elete)</li>
<li><code>dw</code> 删除当前光标下的词 d(elete)w(ord)</li>
</ul>
<h4 id="复制粘贴">复制粘贴</h4><ul>
<li><code>yy</code> 复制当前行 y(ank)</li>
<li><code>yw</code> 复制当前光标下的词 y(ank)w(ord)</li>
<li><code>p</code> 粘贴 p(aste)</li>
<li><code>P</code> 粘贴在当前位置之前</li>
</ul>
<h2 id="进阶操作">进阶操作</h2><p>限于篇幅，在这里我仅介绍下我非常常用的几个操作。</p>
<h3 id="重复操作">重复操作</h3><p>因为VIM所有的操作都是原子化的，所以把这些操作程序化就非常简单了：</p>
<ul>
<li><code>5w</code> 相当于按五次<code>w</code>键；</li>
<li><code>6j</code> 下移6行，相当于按六次j；</li>
<li><code>3J</code> 大写J,本来是将下一行与当前行合并，加上数量，就是重复操作3次；</li>
<li><code>6dw</code>和<code>d6w</code> 结果是一样，就是删除6个word；</li>
<li>剩下的无数情况，自己类推吧。</li>
</ul>
<h3 id="高效编辑">高效编辑</h3><ul>
<li><code>di&quot;</code> 光标在””之间，则删除””之间的内容</li>
<li><code>yi(</code> 光标在()之间，则复制()之间的内容</li>
<li><code>vi[</code> 光标在[]之间，则选中[]之间的内容</li>
<li>以上三种可以自由组合搭配，效率奇高，i(nner)</li>
<li><code>dtx</code> 删除字符直到遇见光标之后的第一个<code>x</code>字符</li>
<li><code>ytx</code> 复制字符直到遇见光标之后的第一个<code>x</code>字符</li>
</ul>
<h3 id="标记和宏(macro)">标记和宏(macro)</h3><ul>
<li><code>ma</code> 将当前位置标记为a，26个字母均可做标记，<code>mb</code>、<code>mc</code>等等；</li>
<li><code>&#39;a</code> 跳转到a标记的位置；</li>
<li>这是一组很好的文档内标记方法，在文档中跳跃编辑时很有用；</li>
<li><code>qa</code> 将之后的所有键盘操作录制下来，直到再次在命令模式按下<code>q</code>，并存储在<code>a</code>中；</li>
<li><code>@a</code> 执行刚刚记录在<code>a</code>里面的键盘操作；</li>
<li><code>@@</code> 执行上一次的macro操作；</li>
<li>宏操作是VIM最为神奇的操作之一，需要慢慢体会其强大之处；</li>
</ul>
<p>VIM的基本操作，可以挖掘的东西非常多，不仅仅需要记忆，更需要自己去探索总结，熟练之后，效率会大幅度提升。后面会给出一些参考链接。</p>
<h2 id="插件管理">插件管理</h2><h3 id="Vundle">Vundle</h3><p>终于到这篇Blog我最想讨论的部分了。VIM的强大不仅仅体现在操作的高效率，更有强大而充沛的插件做支援，插件丰富了之后，就面临查找和管理的问题。</p>
<p>在遇见<a href="https://github.com/gmarik/vundle" target="_blank" rel="external">Vundle</a>之前，我用<a href="https://github.com/tpope/vim-pathogen" target="_blank" rel="external">Pathogen</a>管理插件。Pathogen还算方便，只需要把相应插件，放在<code>bundle</code>目录下即可，不需要再像以前那样逐个放置单独的文件到相应目录，大大节省了劳动力，管理起来也一目了然，觉得还不错，至少比vimball那种需要执行命令安装的方式好一些。</p>
<p>我真希望我早些遇见Vundle。Vundle受到Pathogen和Vimball的启发，于是有了现在的模样。Vundle的逻辑是这样的：</p>
<ul>
<li>在<a href="http://vim-scripts.org/vim/scripts.html" target="_blank" rel="external">Vim Script</a>选好你想要的插件；</li>
<li>在VIM的配置文件中写一句 <code>Bundle plugin_name</code>；</li>
<li>执行一下Vundle的初始化命令，插件就装好了；</li>
<li>升级和卸载也是同样的简单；</li>
</ul>
<p>完美的世界！</p>
<h3 id="Vundle的配置">Vundle的配置</h3><p><a href="https://github.com/gmarik/vundle" target="_blank" rel="external">Vundle</a>的安装很简单：</p>
<pre><code>git clone <span class="symbol">http:</span>/<span class="regexp">/github.com/gmarik</span><span class="regexp">/vundle.git ~/</span>.vim/bundle/vundle
</code></pre><p>然后写配置文件<code>.vimrc</code>：</p>
<pre><code><span class="keyword">set</span> nocompatible    <span class="string">" be iMproved
</span><span class="keyword">filetype</span> off        <span class="string">" required!
</span>
<span class="keyword">set</span> rtp+=~/.<span class="keyword">vim</span>/bundle/vundle/
<span class="built_in">call</span> vundle#rc()

<span class="string">" let Vundle manage Vundle
</span><span class="string">" required!
</span>Bundle <span class="string">'gmarik/vundle'</span>

<span class="string">" vim-scripts repos
</span>Bundle <span class="string">'vim-plugin-foo'</span>
Bundle <span class="string">'vim-plugin-bar'</span>

<span class="keyword">filetype</span> plugin <span class="built_in">indent</span> <span class="keyword">on</span>    " required!
</code></pre><p>其中<code>Bundle</code>后面的内容，就是插件的名字，插件维护在<a href="http://vim-scripts.org/vim/scripts.html" target="_blank" rel="external">Vim-Script.org</a>。</p>
<p>然后，打开VIM之后，可以输入以下命令：</p>
<pre><code><span class="string">"安装插件:</span>
:BundleInstall

<span class="string">"更新插件:</span>
:BundleInstall!

<span class="string">"卸载不在列表中的插件:</span>
:BundleClean
</code></pre><p>现在大部分的插件都已经从<a href="http://www.vim.org/scripts/index.php" target="_blank" rel="external">Vim.org</a>迁移到了<a href="http://vim-scripts.org/vim/scripts.html" target="_blank" rel="external">Vim-Script.org</a>，而且很多作者也认领了自己的插件，直接在这个Github的项目下更新，一个比Vim.org更科学更有效的生态环境，就这样完美的形成了。</p>
<p>在此非常严重的感谢vim-scripts.org的创建者<a href="https://github.com/bronson" target="_blank" rel="external">Scott Bronson</a>，和<a href="https://github.com/gmarik/vundle" target="_blank" rel="external">Vundle</a>的作者<a href="https://github.com/gmarik" target="_blank" rel="external">gmarik</a>。他们的创新和分享精神，让这个世界又美好了一些。</p>
<p>也感谢业界良心<a href="https://github.com/" target="_blank" rel="external">Github</a>。Vim-Scripts.org整站就是用<a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a>建立维护的，对于个人来说，这是很好的选择，有兴趣的同学可以参看我之前的博客：[使用Github Pages建独立博客][9]。</p>
<h2 id="插件介绍">插件介绍</h2><p>有了Vundle，再装插件就是件享受的事情了。我常用的插件有：</p>
<pre><code><span class="preprocessor">#相较于Command-T等查找文件的插件，ctrlp.vim最大的好处在于没有依赖，干净利落</span>
Bundle <span class="string">'ctrlp.vim'</span>

<span class="preprocessor">#在输入()，""等需要配对的符号时，自动帮你补全剩余半个</span>
Bundle <span class="string">'AutoClose'</span>

<span class="preprocessor">#神级插件，ZenCoding可以让你以一种神奇而无比爽快的感觉写HTML、CSS</span>
Bundle <span class="string">'ZenCoding.vim'</span>

<span class="preprocessor">#在()、""、甚至HTML标签之间快速跳转；</span>
Bundle <span class="string">'matchit.zip'</span>

<span class="preprocessor">#显示行末的空格；</span>
Bundle <span class="string">'ShowTrailingWhitespace'</span>

<span class="preprocessor">#JS代码格式化插件；</span>
Bundle <span class="string">'_jsbeautify'</span>

<span class="preprocessor">#用全新的方式在文档中高效的移动光标，革命性的突破</span>
Bundle <span class="string">'EasyMotion'</span>

<span class="preprocessor">#自动识别文件编码；</span>
Bundle <span class="string">'FencView.vim'</span>

<span class="preprocessor">#必不可少，在VIM的编辑窗口树状显示文件目录</span>
Bundle <span class="string">'The-NERD-tree'</span>

<span class="preprocessor">#NERD出品的快速给代码加注释插件，选中，`ctrl+h`即可注释多种语言代码；</span>
Bundle <span class="string">'The-NERD-Commenter'</span>

<span class="preprocessor">#解放生产力的神器，简单配置，就可以按照自己的风格快速输入大段代码。</span>
Bundle <span class="string">'UltiSnips'</span>

<span class="preprocessor">#让代码更加易于纵向排版，以=或,符号对齐</span>
Bundle <span class="string">'Tabular'</span>

<span class="preprocessor">#迄今位置最好的自动VIM自动补全插件了吧</span>
<span class="preprocessor">#Vundle的这个写法，是直接取该插件在Github上的repo</span>
Bundle <span class="string">'Valloric/YouCompleteMe'</span>
</code></pre><p>以上插件可以在<a href="http://vim-scripts.org/vim/scripts.html" target="_blank" rel="external">vim-script.org</a>找到源码和文档，<a href="http://mattn.github.com/zencoding-vim/" target="_blank" rel="external">ZenCoding</a>和<a href="http://net.tutsplus.com/tutorials/other/vim-essential-plugin-easymotion/" target="_blank" rel="external">EasyMotion</a>演示点链接,你会心动的。</p>
<h2 id="-vimrc配置">.vimrc配置</h2><p>因为配置不断在更新，所以放上我的配置的链接：[.vimrc配置][vimrc]</p>
<h2 id="更多">更多</h2><p>VIM在一开始会觉得非常不习惯，一定要坚持下去，收获的会更多，不仅仅是在装大侠方面的哦~</p>
<p>关于VIM的使用，这篇博客仅仅介绍了很小的一部分，网络上还有大量朋友总结的心得，常学常有收获：</p>
<ul>
<li><a href="http://book.douban.com/subject/10599776/" target="_blank" rel="external">Practical Vim</a>，强烈推荐的一本系统介绍VIM的书籍</li>
<li><a href="http://overapi.com/vim/" target="_blank" rel="external">Vim Cheat Sheet</a>，有VIM的各种助记图，可以作为桌面</li>
<li><a href="http://www.vimer.cn/" target="_blank" rel="external">Vimer的程序世界</a>，不错的站，博主持续钻研VIM各种技巧</li>
<li><a href="http://hi.baidu.com/whqvzhjoixbbdwd/item/11315a5073667d0de6c4a5e9" target="_blank" rel="external">网友狂人收集的vim资料链接</a></li>
<li><a href="http://www.rayninfo.co.uk/vimtips.html" target="_blank" rel="external">Best of Vim Tips</a></li>
<li><a href="http://www.limboy.com/2009/05/30/vim-setting/" target="_blank" rel="external">面向前端开发者和TextMate粉丝的vim配置</a></li>
<li><a href="http://scmbob.org/vim_fdm.html" target="_blank" rel="external">Vim代码折叠简介</a></li>
<li><a href="http://blog.longwin.com.tw/2009/03/choose-vim-color-scheme-2009/" target="_blank" rel="external">挑選 Vim 顏色(Color Scheme)</a></li>
<li><a href="https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb" target="_blank" rel="external">vimium</a>，用VIM的操作习惯来控制Chrome的插件</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[在Git流行的时代，VIM的生态环境也有了长足的进步，令人感动。]]>
    
    </summary>
    
      <category term="vim" scheme="http://ppii.in/blog/blog/tags/vim/"/>
    
      <category term="技术笔记" scheme="http://ppii.in/blog/blog/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript中的创建对象的几种模式对比]]></title>
    <link href="http://ppii.in/blog/blog/2014/05/23/javascript-createobject/"/>
    <id>http://ppii.in/blog/blog/2014/05/23/javascript-createobject/</id>
    <published>2014-05-22T16:00:00.000Z</published>
    <updated>2015-07-11T14:27:53.413Z</updated>
    <content type="html"><![CDATA[<h2 id="创建对象">创建对象</h2><h4 id="1-_工厂模式">1. 工厂模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createShape</span>(<span class="params">x, func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.x = x;</span><br><span class="line">    o.func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shape = createShape(x, func);</span><br></pre></td></tr></table></figure>
<p>无法进行对象识别（识别对象的类型）</p>
<h4 id="2-_构造函数模式">2. 构造函数模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params">x, func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shape = <span class="keyword">new</span> Shape(x, func);</span><br></pre></td></tr></table></figure>
<p>经历的步骤：</p>
<p>1) 创建一个新对象</p>
<p>2) 将构造函数的作用域赋给新对象（this指向这个新对象）</p>
<p>3) 执行构造函数中代码。</p>
<p>4) 返回新对象。</p>
<p>特点：每个构造函数都实例化了一个新的对象。不同实例的同名方法是不相等的。</p>
<p><code>alert(a.func == b.func); // false</code></p>
<p>可解决方案：将方法func提出到外部作用域，然后<code>this.func = func;</code>。但是却使得自定义类失去封装性。</p>
<h4 id="3-_原型模式">3. 原型模式</h4><h4 id="4-_组合使用构造函数模式和原型模式(recommended)">4. 组合使用构造函数模式和原型模式(recommended)</h4><h4 id="5-_动态原型模式">5. 动态原型模式</h4><h4 id="6-_寄生构造函数模式(not_recommended)_不能依赖instanceof来确定对象类型">6. 寄生构造函数模式(not recommended) 不能依赖instanceof来确定对象类型</h4><h4 id="7-_稳妥构造函数模式">7. 稳妥构造函数模式</h4>]]></content>
    <summary type="html">
    <![CDATA[Object大法好]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://ppii.in/blog/blog/tags/JavaScript/"/>
    
      <category term="前端笔记" scheme="http://ppii.in/blog/blog/categories/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>