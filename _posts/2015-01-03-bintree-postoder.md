---
layout: post
title: 二叉树的后序非递归遍历
description: 二叉树作为一种十分重要的数据结构，基本的遍历方式有三种，先序，中序，后序。一般可以用递归的形式来遍历。而非递归则需要采用堆栈俩模拟，其中先序和中序较好实现，但后序相对会难点。
category: notes
tags: [css]
---

{% include JB/setup %}    

二叉树是一种非常重要的数据结构，很多其它数据结构都是基于二叉树的基础演变而来的。对于二叉树，有前序、中序以及后序三种遍历方法。因为树的定义本身就是递归定义，因此采用递归的方法去实现树的三种遍历不仅容易理解而且代码很简洁。而对于树的遍历若采用非递归的方法，就要采用栈去模拟实现。在三种遍历中，前序和中序遍历的非递归算法都很容易实现，非递归后序遍历实现起来相对来说要难一点。

###后序遍历

#### 后序遍历按照“左孩子-右孩子-根结点”的顺序进行访问。

- 递归实现
    void postOrder1(BinTree *root)    //递归后序遍历
    {
        if(root!=NULL)
        {
            postOrder1(root->lchild);
            postOrder1(root->rchild);
            cout<<root->data<<" ";
        }    
    } 

- 非递归实现

这里要保证左子和右子都已经被访问之后，并且左子在右子前访问，才能访问根节点。就这对流程有较大的影响。

这里根据查阅资料提供两个思路：

 第一种思路：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该结点是否是第一次出现在栈顶。

 第二种思路：要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。


http://www.cnblogs.com/dolphin0520/archive/2011/08/25/2153720.html
 